#!/usr/bin/python
#
# mkiso, version 1.0, by John Wiegley <johnw@newartisans.com>
#
# Helper application for archiving files to disc.  When mkiso is run, it will
# create .iso images, split to fit on the target media (whose byte size is
# defined by `target_size').  These images are recorded in the directory given
# by `output_dir'.  To begin the process AFTER a particular file basename
# (typically the last file of the last series), give that basename as the
# first argument.
#
# This script relies on "mkisofs" to do its work.

import sys
import string
import re
import os

from stat import *
from os.path import *

file_regexp = "([0-9]{6}_[0-9]{4})[^.]*\.(psd|jpg|cr[w2])$"
target_size = 4603097088L              # size of the DVDs I use
output_dir  = "/Volumes/My Book"       # where to make the .iso files
print_only  = False                    # -n
first_name  = None                     # --first NAME
last_name   = None                     # --last NAME

files       = {}
have_errors = False

def bytestring(amount):
    if amount < 1024:
        return "%d b" % amount
    elif amount < 1024 * 1024:
        return "%d Kb" % (amount / 1024)
    elif amount < 1024 * 1024 * 1024:
        return "%.1f Mb" % (amount / (1024.0 * 1024.0))
    elif amount < 1024 * 1024 * 1024 * 1024:
        return "%.2f Gb" % (amount / (1024.0 * 1024.0 * 1024.0))

def find_files(path):
    entries = os.listdir(path)
    for entry in entries:
        base = entry
        entry = join(path, entry)
        if isfile(entry):
            match = re.match(file_regexp, base, re.IGNORECASE)
            if match:
                name = match.group(1)
                if (last_name and name <= last_name) or \
                   (first_name and name < first_name):
                    continue
                info = os.stat(entry)
                if not files.has_key(name):
                    files[name] = [info[ST_SIZE], entry]
                else:
                    files[name].append(entry)
                    files[name][0] += info[ST_SIZE]
        elif isdir(entry):
            find_files(entry)

image_list = []

def report_size (begin, end, size):
    if size > target_size:
        print "%s-%s: %s (TOO BIG!)" % \
              (begin, end, bytestring(size))
        have_errors = True
    else:
        print "%s-%s: %s" % (begin, end, bytestring(size))

    image_list.append([begin, end])

label = "Backup"
index = 1

def create_image (begin, end):
    global index
    if index > 1:
        title = "%s-%d" % (label, index)
    else:
        title = label
    index += 1
    iso = os.popen("mkisofs -quiet -J -r -V \"%s\" -path-list - -o \"%s.iso\"" %
                   (title, join(output_dir, title)), "w")
    keys = files.keys()
    keys.sort()
    for name in keys:
        if name >= begin and name <= end:
            for file in files[name][1:]:
                iso.write("%s\n" % file)
    iso.close()


args = sys.argv[1:]

while len(args) and args[0][0] == '-':
    if args[0] == "-h" or args[0] == "--help":
        print "usage: mkiso [-n] [--first NAME] [--last NAME] [--include REGEXP]"
        print "             [-o DIR | --output DIR] [--size SIZE] [--label LABEL]"
        sys.exit(0)
    elif args[0] == "-n":
        print_only = True
        args = args[1:]
    elif args[0] == "--first":
        first_name = args[1]
        args = args[2:]
    elif args[0] == "--last":
        last_name = args[1]
        args = args[2:]
    elif args[0] == "--size":
        target_size = long(args[1])
        args = args[2:]
    elif args[0] == "--label":
        label = args[1]
        args = args[2:]
    elif args[0] == "-i" or args[0] == "--include":
        file_regexp = args[1]
        args = args[2:]
    elif args[0] == "-o" or args[0] == "--output":
        output_dir = args[1]
        args = args[2:]

if not print_only and not isdir(output_dir):
    print "Output directory '%s' is not valid" % output_dir
    sys.exit(1)

if not last_name and not first_name and \
   isdir(output_dir) and isfile(join(output_dir, ".lastimage")):
    lastimage = open(join(output_dir, ".lastimage"), "r")
    last_name = lastimage.read()
    lastimage.close()

for path in args:
    if isdir(path):
        find_files(path)

keys = files.keys()
keys.sort()
if len(keys) == 0:
    print "There are no files to archive"
    sys.exit(1)

first_name = keys[0]
prev_name  = first_name
size       = 0

for name in keys:
    new_size = size + files[name][0]
    if new_size > target_size:
        report_size(first_name, prev_name, size)
        size = files[name][0]
        first_name = name
    else:
        size = new_size
    prev_name = name

if size > 0:
    assert first_name
    report_size (first_name, keys[-1], size)

if have_errors:
    print "At least one of the archive images will be too big"
    sys.exit(1)

if print_only:
    sys.exit(0)

if len(image_list) == 0:
    print "There are no images to create"
    sys.exit(1)

for image in image_list:
    create_image(image[0], image[1])

lastimage = open(join(output_dir, ".lastimage"), "w")
lastimage.write(image_list[-1][1])
lastimage.write("\n")
lastimage.close()
