#!/usr/bin/env python

import sys
import re

def sort_timelog(a, b):
    match1 = re.match('([ioIO]) ([0-9]{2})/([0-9]+)/([0-9]{4}) ([0-9]+):([0-9]+):([0-9]+)',
                      a)
    if match1:
        (mode1, mon1, day1, year1, hour1, minute1, sec1) = match1.groups()

        match2 = re.match('([ioIO]) ([0-9]+)/([0-9]+)/([0-9]+) ([0-9]+):([0-9]+):([0-9]+)',
                          b)
        (mode2, mon2, day2, year2, hour2, minute2, sec2) = match2.groups()
    else:
        match1 = re.match('([ioIO]) ([0-9]+)/([0-9]+)/([0-9]+) ([0-9]+):([0-9]+):([0-9]+)',
                          a)
        (mode1, year1, mon1, day1, hour1, minute1, sec1) = match1.groups()

        match2 = re.match('([ioIO]) ([0-9]+)/([0-9]+)/([0-9]+) ([0-9]+):([0-9]+):([0-9]+)',
                          b)
        (mode2, year2, mon2, day2, hour2, minute2, sec2) = match2.groups()

    if int(year1) < int(year2):
        return -1
    elif int(year1) > int(year2):
        return 1

    if int(mon1) < int(mon2):
        return -1
    elif int(mon1) > int(mon2):
        return 1

    if int(day1) < int(day2):
        return -1
    elif int(day1) > int(day2):
        return 1

    if int(hour1) < int(hour2):
        return -1
    elif int(hour1) > int(hour2):
        return 1

    if int(minute1) < int(minute2):
        return -1
    elif int(minute1) > int(minute2):
        return 1

    if int(sec1) < int(sec2):
        return -1
    elif int(sec1) > int(sec2):
        return 1

    #if mode1.lower() < mode2.lower():
    #    return -1
    #elif mode1.lower() > mode2.lower():
    #    return 1

    return 0

def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return K

map(lambda x: sys.stdout.write(x),
    sorted(sys.stdin.readlines(), key=cmp_to_key(sort_timelog)))
